
#include <PM_test_task.h>
#include <task.h>
#include <UART_16550.h>
#include <pulse_modulator.h>
#include <stdio.h>

// "screen /dev/ttyUSB1 9600"
// https://deepbluembedded.com/sine-lookup-table-generator-calculator/
const uint16_t sineLookupTable[] = {
  0x80, 0x83, 0x86, 0x89, 0x8d, 0x90, 0x93, 0x96, 0x99, 0x9c,
  0x9f, 0xa2, 0xa5, 0xa8, 0xab, 0xae, 0xb1, 0xb4, 0xb7, 0xba,
  0xbc, 0xbf, 0xc2, 0xc4, 0xc7, 0xca, 0xcc, 0xcf, 0xd1, 0xd4,
  0xd6, 0xd8, 0xdb, 0xdd, 0xdf, 0xe1, 0xe3, 0xe5, 0xe7, 0xe9,
  0xea, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf7,
  0xf9, 0xfa, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xfe, 0xff, 0xff,
  0xff, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0xff, 0xff,
  0xff, 0xfe, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xfa, 0xf9, 0xf7,
  0xf6, 0xf5, 0xf4, 0xf2, 0xf1, 0xef, 0xee, 0xec, 0xea, 0xe9,
  0xe7, 0xe5, 0xe3, 0xe1, 0xdf, 0xdd, 0xdb, 0xd8, 0xd6, 0xd4,
  0xd1, 0xcf, 0xcc, 0xca, 0xc7, 0xc4, 0xc2, 0xbf, 0xbc, 0xba,
  0xb7, 0xb4, 0xb1, 0xae, 0xab, 0xa8, 0xa5, 0xa2, 0x9f, 0x9c,
  0x99, 0x96, 0x93, 0x90, 0x8d, 0x89, 0x86, 0x83, 0x80, 0x7d,
  0x7a, 0x77, 0x73, 0x70, 0x6d, 0x6a, 0x67, 0x64, 0x61, 0x5e,
  0x5b, 0x58, 0x55, 0x52, 0x4f, 0x4c, 0x49, 0x46, 0x44, 0x41,
  0x3e, 0x3c, 0x39, 0x36, 0x34, 0x31, 0x2f, 0x2c, 0x2a, 0x28,
  0x25, 0x23, 0x21, 0x1f, 0x1d, 0x1b, 0x19, 0x17, 0x16, 0x14,
  0x12, 0x11, 0x0f, 0x0e, 0x0c, 0x0b, 0x0a, 0x09, 0x07, 0x06,
  0x06, 0x05, 0x04, 0x03, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02,
  0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x09, 0x0a, 0x0b,
  0x0c, 0x0e, 0x0f, 0x11, 0x12, 0x14, 0x16, 0x17, 0x19, 0x1b,
  0x1d, 0x1f, 0x21, 0x23, 0x25, 0x28, 0x2a, 0x2c, 0x2f, 0x31,
  0x34, 0x36, 0x39, 0x3c, 0x3e, 0x41, 0x44, 0x46, 0x49, 0x4c,
  0x4f, 0x52, 0x55, 0x58, 0x5b, 0x5e, 0x61, 0x64, 0x67, 0x6a,
  0x6d, 0x70, 0x73, 0x77, 0x7a, 0x7d};

void PM_test_task(void *pvParameters){
  long long int val = 0;
  unsigned basefrequency = 38400;
  unsigned divisions = 256;
  unsigned dutyCycle = 50;

  TickType_t lastwake = xTaskGetTickCount();

  // Set up channel 0 (Audio Jack)
  PM_acquire(0);
  PM_set_handler(0, PM_test_task_handler);
  PM_set_cycle_time(0,divisions,basefrequency);
  PM_set_PDM_mode(0);
  PM_enable_FIFO(0);
  PM_enable(0);
  PM_enable_interrupt(0);
  PM_set_duty(0,divisions/100*dutyCycle);

  unsigned clkdiv = (PM_CLOCK/(divisions * basefrequency)) - 1;
  unsigned baseclk = PM_CLOCK / (clkdiv + 1);
  unsigned BCR = baseclk / basefrequency - 1;

  char buffer[64];
  sprintf(buffer, "divisions: %d, base freq: %d, CDR: %d, BCR: %d\r\n", divisions, basefrequency, clkdiv, BCR);
  UART_16550_write_string(UART0,buffer,portMAX_DELAY);
  while(1){

    if(!PM_FIFO_full(0)){
      sprintf(buffer, " %d\r", val);
      UART_16550_write_string(UART0,buffer,portMAX_DELAY);
      val += 1;
      if (val > 99)
        val = 0;
      // PM_set_duty(0,sineLookupTable[val]); 
    }

    // PM_set_duty(1,sineLookupTable[val]); 
    // PM_set_duty(2,sineLookupTable[val]);
    // PM_set_duty(2,val); 
  }
}

void PM_test_task_handler(void){
  static unsigned int val = 0;

  // While the PM FIFO is not full,
  //   Transfer a data item from the buffer to the FIFO
  while(!PM_FIFO_full(0)){
    //   You may not have a valid buffer (the mixer may not
    //   have run yet) In that case, write a zero .
    val += 1; 
    PM_set_duty(0,sineLookupTable[val]); 
    if (val > sizeof(sineLookupTable)) 
      val = 0;
  
    //   If you send the last item in your current buffer, then send the
    //   pointer back to the mixer and get another buffer from the
    //   mixer.
  }
}

/* Dimensions the buffer that the task being created will use as its
stack. NOTE: This is the number of words the stack will hold, not the
number of bytes. For example, if each stack item is 32-bits, and this
is set to 100, then 400 bytes (100 * 32-bits) will be allocated. */
#define PM_TEST_STACK_SIZE 256

/* Structure that will hold the TCB of the task being created. */
StaticTask_t PM_test_TCB;

/* Buffer that the task being created will use as its stack. Note this
is an array of StackType_t variables. The size of StackType_t is
dependent on the RTOS port. */
StackType_t PM_test_stack[ PM_TEST_STACK_SIZE ];



