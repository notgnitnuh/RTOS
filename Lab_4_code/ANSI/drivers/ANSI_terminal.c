/* 
   A very simple set of functions to perform operations on ANSI terminals.
   Author: Larry D. Pyeatt
   Date: 2/18/1995
   Extended: 9/1/2009
   (C) All rights reserved


   These functions rely on the functions provided by the lower level
   device-specific drivers.

   A thorough description of ANSI escape sequences for input and
   output can be found at:
   https://en.wikipedia.org/wiki/ANSI_escape_code
 
*/

#include <ANSI_terminal.h>
#include <uart_driver_table.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <curspriv.h>

//------------------------------------------------------------------------
// When the user hits a special key (left arrow, right arrow, pgup,
// pgdown, etc), the terminal sends an escape sequence.  We have to
// decode such sequences and convert them into a single character
// value for the key that was pressed.  We use character values with
// the topmost bit set to one to represent special keys. See
// drivers/ANSI_device.h for the table.

// Structure for creating a table of keyboard escape sequences.
typedef struct {
  uint8_t chr,key;
}ktab_entry;

// The following table contains most of the keyboard escape sequences
// for the VT100 terminal.  We assume that we have already read 0x1b,
// and now need to use this table. We have assigned keycode values
// above 0x7F to the special keys, so that just checking for a higher
// number allows us to quit the search and return a keycode. This
// table does not cover all of the keys, but it is a good start.
static ktab_entry ktab[] =
  {
    {0x4F,3},          // if 'O' then go to row three
    {0x5B,16},         // if '[' then go to row 16
    {0x00,0xFF },      // failed sequence
    {0x50,Key_F1},     // F1  row 3:  sequences of the form 1b 4F XX
    {0x51,Key_F2},     // F2
    {0x52,Key_F3},     // F3
    {0x53,Key_F4},     // F4
    {0x54,Key_F5},     // F5 - broken
    {0x55,Key_F6},     // F6 - broken
    {0x56,Key_F7},     // F7 - broken
    {0x57,Key_F8},     // F8 - broken
    {0x58,Key_F9},     // F9 - broken
    {0x59,Key_F10},    // F10 - broken
    {0x5A,Key_F11},    // F11 - broken
    {0x5B,Key_F12},    // F12 - broken
    {0x00,0xFF},       // failed sequence
    {0x41,Key_UpArrow},// row 16:  sequences of the form 1B 5B XX
    {0x42,Key_DnArrow},
    {0x43,Key_RgtArrow},
    {0x44,Key_LftArrow},
    {0x46,Key_End},
    {0x48,Key_Home},
    //    Row 21:  sequences of the form 1B 5B XX 7E
    {0x31,29},         
    {0x32,31},         
    {0x33,33},
    {0x34,35},
    {0x35,37},
    {0x36,39},
    {0x00,0xFF},       // failed sequence
    {0x7E,Key_Home},
    {0x00,0xFF},       // failed sequence
    {0x7E,Key_Insert},
    {0x00,0xFF},       // failed sequence
    {0x7E,Key_Del},
    {0x00,0xFF},       // failed sequence
    {0x7E,Key_End},
    {0x00,0xFF},       // failed sequence
    {0x7E,Key_PgUp},
    {0x00,0xFF},       // failed sequence
    {0x7E,Key_PgDn},
    {0x00,0xFF}        // failed sequence
  };

//------------------------------------------------------------------------------
// The translate function is used by getChar to convert multi-byte
// sequences from function keys, arrow keys, etc. into the keycodes
// listed in ANSI_device.h

static uint8_t translate(int uart)
{
  int row = 0;
  uint8_t ch;
  BaseType_t result = pdPASS;
  // we got an esc character.  Either it is a special key sequence
  // (generated by pressing pgup, pgdown, function key, arrow key,
  // etc) or the user pressed the esc key. If it is a special key
  // sequence, then the next character should be ready within a few
  // milliseconds.  We wait for a short period, then do a non-blocking
  // read.  If the read fails, we assume the user pressed the esc key.
  result = ANSI_uart.get_char(uart,&ch,10);// Will block for up to 10 ticks
  if(result != pdPASS)     // If the read failed.
    return Key_ESC;        //   return the Esc character.
  // if we got another character, then assume it is a multi-char sequence
  while(row < 0x80)
    {
      // search for match to ch, starting at row
      while((ktab[row].chr != 0) && (ktab[row].chr != ch))
        row++;
      // Either found a match, or ran out of options
      row = ktab[row].key;
      // If we found a match and it is not the end of a sequence, then
      // read next char and continue matching the sequence.
      if(row < 0x80)
        ANSI_uart.get_char(uart,&ch,1);
    }
  return row;
}

//------------------------------------------------------------------------------
// Read a char from keyboard and handle the fancy keys that generate
// multi-byte escape sequences.  This function will block until a
// character is available.
uint8_t ANSI_getChar(int uart)
{
  uint8_t ch;
  ANSI_uart.get_char(uart,&ch,portMAX_DELAY);
  if(ch == 0x1B)
    ch = translate(uart);
  return ch;
}

//------------------------------------------------------------------------------
// Tell terminal to clear the screen
void ANSI_clear(int uart)
{
  ANSI_uart.write_string(uart,"\e[2J",portMAX_DELAY);
}

//------------------------------------------------------------------------------
// Tell terminal to clear from cursor to end of line
void ANSI_cleartoeol(int uart)
{
  // Students insert code here
}

//------------------------------------------------------------------------------
// Tell terminal to save the current cursor position
void ANSI_saveCursor(int uart)
{
  ANSI_uart.write_string(uart,"\e[s",portMAX_DELAY);
}

//------------------------------------------------------------------------------
// Tell terminal to restore the previouly saved cursor position
void ANSI_restoreCursor(int uart)
{
  ANSI_uart.write_string(uart,"\e[u",portMAX_DELAY);
}

//------------------------------------------------------------------------------
// Tell terminal to hide the cursor
void ANSI_hideCursor(int uart)
{
  // Students insert code here
}

//------------------------------------------------------------------------------
// Tell terminal to move the cursor left one character
void ANSI_moveLeft(int uart)
{
  // Students insert code here
}

//------------------------------------------------------------------------------
// Tell terminal to move the cursor right one character
void ANSI_moveRight(int uart)
{
  ANSI_uart.write_string(uart,"\e[1C",portMAX_DELAY);
}

//------------------------------------------------------------------------------
// Tell terminal to show the cursor
void ANSI_showCursor(int uart)
{
  ANSI_uart.write_string(uart,"\e[?25h",portMAX_DELAY);
}

//------------------------------------------------------------------------------
// Tell terminal to move the cursor
void ANSI_moveTo(int uart,int row, int col)
{
  char buf[16];
  row++;
  col++;
  ANSI_uart.tx_lock(uart,portMAX_DELAY);
  ANSI_uart.write_string(uart,"\e[",portMAX_DELAY);
  sprintf(buf,"%d",row);
  ANSI_uart.write_string(uart,buf,portMAX_DELAY);
  ANSI_uart.put_char(uart,';',portMAX_DELAY);
  sprintf(buf,"%d",col);
  ANSI_uart.write_string(uart,buf,portMAX_DELAY);
  ANSI_uart.put_char(uart,'H',portMAX_DELAY);
  ANSI_uart.tx_unlock(uart);
}

// Select alternate character set
void ANSI_altCharSet(int uart)
{
  ANSI_uart.write_string(uart,"\e(0",portMAX_DELAY);  
}

// Select normal character set
void ANSI_normalCharSet(int uart)
{
  ANSI_uart.write_string(uart,"\e(B",portMAX_DELAY);  
}

// reset all character attributes to default
void ANSI_clearAttrs(int uart)
{
  ANSI_uart.write_string(uart,"\e[0m",portMAX_DELAY);
}

// start/stop blinking
void ANSI_toggleBlinking(int uart)
{
  ANSI_uart.write_string(uart,"\e[5m",portMAX_DELAY);
}
    
// start/stop italics
void ANSI_toggleItalics(int uart)
{
  // Students insert code here
}

// start/stop bold
void ANSI_toggleBold(int uart)
{
  ANSI_uart.write_string(uart,"\e[1m",portMAX_DELAY);
}

// start/stop underline
void ANSI_toggleUnderline(int uart)
{
  ANSI_uart.write_string(uart,"\e[4m",portMAX_DELAY);
}

// start/stop strikethrough
void ANSI_toggleStrikethrough(int uart)
{
  ANSI_uart.write_string(uart,"\e[9m",portMAX_DELAY);
}

// start/stop reverse video
void ANSI_toggleReverse(int uart)
{
  ANSI_uart.write_string(uart,"\e[7m",portMAX_DELAY);
}

// start/stop dim 
void ANSI_toggleDim(int uart)
{
  ANSI_uart.write_string(uart,"\e[2m",portMAX_DELAY);
}


//------------------------------------------------------------------------------
// Draw a border around the field at row, col with given width
int ANSI_drawBorder(int uart,int row, int col, int width)
{
  int i;
  if(row<0 || col < 0 || row > 24 || col+width > 79)
    return -1;
  ANSI_uart.tx_lock(uart,portMAX_DELAY);
  ANSI_saveCursor(uart);
  ANSI_uart.write_string(uart,"\e(0",portMAX_DELAY);      // switch to line drawing character set
  ANSI_moveTo(uart,row-1,col-1);
  ANSI_uart.put_char(uart,'l',portMAX_DELAY);
  for(i=0;i<width;i++)
    ANSI_uart.put_char(uart,'q',portMAX_DELAY);
  ANSI_uart.put_char(uart,'k',portMAX_DELAY);
  ANSI_moveTo(uart,row,col-1);
  ANSI_uart.put_char(uart,'x',portMAX_DELAY);
  ANSI_moveTo(uart,row,col+width);
  ANSI_uart.put_char(uart,'x',portMAX_DELAY);
  ANSI_moveTo(uart,row+1,col-1);
  ANSI_uart.put_char(uart,'m',portMAX_DELAY);
  for(i=0;i<width;i++)
    ANSI_uart.put_char(uart,'q',portMAX_DELAY);
  ANSI_uart.put_char(uart,'j',portMAX_DELAY);
  ANSI_uart.write_string(uart,"\e(B",portMAX_DELAY);      // switch to ASCII character set
  ANSI_restoreCursor(uart);
  ANSI_uart.tx_unlock(uart);
  return 0;
}


//------------------------------------------------------------------------------
void ANSI_setColor(int uart,int color)
{
  // Students insert code here
}


//------------------------------------------------------------------------------
void ANSI_bell(int uart)
{
  ANSI_uart.write_string(uart,"\007",portMAX_DELAY);
}


//------------------------------------------------------------------------------
void ANSI_getCursorPos(int uart,int *x,int *y)
{
  char ybuf[4]={0},xbuf[4]={0},c;
  int xlen=0,ylen=0;
  ybuf[0] = xbuf[0] = '0';

  // get mutexes for the transmitter and receiver
  ANSI_uart.tx_lock(uart,portMAX_DELAY);
  ANSI_uart.rx_lock(uart,portMAX_DELAY);

  // flush the receive queue and fifo
  ANSI_uart.flush_rx(uart);

  // We need a function that allows us to block until the transmit
  // buffer and fifo are empty, but we don't have it yet and this code
  // usually works okay without it.
  //   ANSI_uart_wait_tx_empty(uart);
  
  // send command to request cursor position
  ANSI_uart.write_string(uart,"\e[6n",portMAX_DELAY);
  // read from UART until we find an escape character
  do
    ANSI_uart.get_char(uart,&c,portMAX_DELAY);
  while(c != '\e');
  
  // now read the rest of the escape sequence
  ANSI_uart.get_char(uart,&c,portMAX_DELAY);
  if(c != '[')
    ANSI_uart.write_string(uart,"Missing '[' in getCursorPos\n",portMAX_DELAY);
  else
    {
      do
        {
          ANSI_uart.get_char(uart,&c,portMAX_DELAY);
          if(c != ';')
            ybuf[ylen++] = c;
        }
      while(c != ';');
      do
        {
          ANSI_uart.get_char(uart,&c,portMAX_DELAY);
          if(c != 'R')
            xbuf[xlen++] = c;
        }
      while(c != 'R');
    }
  ANSI_uart.rx_unlock(uart);
  ANSI_uart.tx_unlock(uart);
  *x = atoi(xbuf);
  *y = atoi(ybuf);
}


//------------------------------------------------------------------------------
void ANSI_getScreenSize(int uart, int *width, int *height)
{
  ANSI_uart.tx_lock(uart,portMAX_DELAY);
  ANSI_saveCursor(uart);
  ANSI_moveTo(uart,999,999);
  ANSI_getCursorPos(uart,width,height);
  ANSI_restoreCursor(uart);
  ANSI_uart.tx_unlock(uart);
}

//------------------------------------------------------------------------------
// reset all modes (styles and colors)
void ANSI_resetScreen(int uart)
{
  ANSI_uart.write_string(CURSES_UART,"\e[0m",portMAX_DELAY);
}





